# Отчёт по лабораторной работе №2

## Обработка списков, обработка данных

## по курсу "Функциональное программирование"

### студент: Волошинская Евгения, группа М8О-406Б-21, вариант 8

## Результат проверки

|Имя        |Группа      | # в группе |Дата| Оценка|
|------------|-----------|-----------------|----|
|Voloshinskaya Evgeniya|М8О-406Б-21 (prev. М8О-407Б-20)| 8|    | |


## Введение

Списки в F# немного отличаются от того, что обычно называют списками в императивных языках программирования. Во-первых,
списки в F# являются неизменяемыми, что ведет к некоторым трудностям, зато обеспечивает безопасность. Также в F# любой 
список можно представить как голову и хвост, но в отличие от Prolog можно взять несколько головных элементов. Работа со списками в F# немного напоминает работу с очередями (так как обход списка чаще всего делается через отделение головного элемента от остальной части) или массивами.

## Часть 1: Обработка списков

### Вариант 8: Нахождение минимального произведения соседних элементов списка

### С использованием библиотечных функций

```(F#)
let minProductOfNeighbours1 (lst: float list) =
    match lst with
    | [] | [_] -> None // Если список пустой или содержит только один элемент, возвращаем None
    | _ ->
        lst
        |> List.pairwise // Создаем пары соседних элементов
        |> List.map (fun (x, y) -> x * y) // Вычисляем произведение каждой пары
        |> List.min // Находим минимальное произведение
        |> Some // Возвращаем минимальное произведение, обернутое в тип 'a option
```

### Рекурсивно, без использования библиотечных функций

```(F#)
let rec minProductOfNeighbours2 (lst: float list) =
    let rec loop lst minProd =
        match lst with
        | [] | [_] -> Some minProd
        | x::y::t ->
            let prod = x * y
            if prod < minProd then
                loop (y::t) prod
            else
                loop (y::t) minProd
    
    match lst with
    | [] | [_] -> None
    | x::y::t -> loop (y::t) (x * y)
```

### Рекурсивно, без использования библиотечных функций, с хвостовой рекурсией

```(F#)
let rec tailRec lst minProd =
    match lst with
    | [] | [_] -> Some minProd
    | x::y::t ->
        if (x * y) < minProd then
            tailRec (y::t) (x * y)
        else
            tailRec (y::t) minProd
let rec minProductOfNeighbours3 (lst: float list) =  
    match lst with
    | [] | [_] -> None
    | x::y::t -> tailRec (y::t) (x * y)
```

Фактически оба рекурсивных алгоритма содержат хвостовую рекурсию, так как в обоих случаях вызов рекурсивной функции
является последней операцией в функции.
Это обусловлено самим заданием, в котором минимальное произведение должно передаваться по рекурсии, при этом никаких дополнительных переменных и адресов возврата хранить не надо, минимальное произведение само является аккумулятором в функции.

## Часть 2: Обработка данных

### Вариант 8

Способ хранения данных: `One.fsx`

Task 3:
- Для каждого студента, напечатайте его среднюю оценку и сдал ли он сессию (все оценки > 2)
- Для каждого предмета, напечатайте список двоечников
- Для каждой группы, найдите студента (или студентов) с максимальной суммарной оценкой

### Исходный код

```(F#)
// Часть 2. Запросы к базе данных студентов (формат базы - "One.fsx")

// Load the data
#load "One.fsx"
open One

// Task 3.1. Для каждого студента, напечатайте его среднюю оценку и сдал ли он сессию (все оценки > 2)
let averageMarks =
    Data.marks
    |> List.groupBy (fun (student, _, _) -> student) // группируем по формату: ("Петров", ["Петров","LP",4], ["Петров","MTH",4], ...); ...
    |> List.map (fun (student, values) ->
        let isFail = values |> List.exists (fun (_, _, mark) -> mark = 2) // проверяем, есть ли двойки
        let averageMark = List.averageBy (fun (_, _, mark) -> float mark) values // считаем средний балл
        student, averageMark, not isFail) // записываем в переменную-список


// Task 3.2. Для каждого предмета, напечатайте список двоечников
let studentsFailed =
    Data.marks
    |> List.filter (fun (_, _, mark) -> mark = 2) // ищем строки с оценкой 2
    |> List.groupBy (fun (_, subject, _) -> subject) // группируем их по предмету
    |> List.map (fun (subject, values) -> 
        let students = values |> List.map (fun (student, _, _) -> student) // извлекаем фамилии студентов
        subject, students)

// ищем полное название для аббревиатур предметов в Data.subjs, если существует
let findSubjectFull (subject: string) =
    match List.tryFind (fun (k, _) -> k = subject) Data.subjs with
    | Some (_, value) -> value
    | _ -> ""


// Task 3.3. Для каждой группы, найдите студента (или студентов) с максимальной суммарной оценкой
let maxTotalScore =
    Data.marks 
    |> Seq.groupBy (fun (student, _, _) -> (student, Seq.pick (fun (s, g) -> // для каждого студента ищем его группу в Data.studs
        if s = student then Some g else None) Data.studs)) // и группируем оценки по паре (студент, группа)
    |> Seq.map (fun ((student, group), marks) -> 
        (student, group, Seq.sumBy (fun (_, _, mark) -> mark) marks)) // создаем новую последовательность, суммируя оценки для каждого студента
    |> Seq.groupBy (fun (_, group, _) -> group) // группируем (студент, группа, сумм. оценка) по учебной группе
    |> Seq.map (fun (group, students_info) -> 
        let maxStudent_info = Seq.maxBy (fun (_, _, totalScore) -> totalScore) students_info
        (group, maxStudent_info)) // выбираем студента с максимальным баллом для каждой группы и создаем послед-ть (группа, студент, группа, макс. сумм. балл)
    |> Seq.map (fun (group, (student, _, _)) -> (group, student)) // создаем посл-ть (студент, макс. сумм. балл)
    |> List.ofSeq // создаем список из посл-ти
    |> List.sortBy (fun (k, _) -> k) // сортируем по возрастанию номера группы 


printfn "\tTask 3.1: Средняя оценка студента и сдал ли он сессию\n"
for (student, averageMark, isFail) in averageMarks do
    printfn "%-20s %f  %-5b" student averageMark isFail
printf "\n\n\n"

printfn "\tTask 3.2: Список двоечников по предметам\n"
for (subject, students) in studentsFailed do
    let subjectFull = findSubjectFull subject // для каждого предмета ищем полное название
    printf "%-35s |  " subjectFull
    for student in students do
        printf "%s; " student
    printfn ""
printf "\n\n\n"

printfn "\tTask 3.3: Студенты с максимальной суммарной оценкой по группам\n"
for (group, student) in maxTotalScore do
    printfn "%d: %s" group student
```

### Результат работы:

```
        Task 3.1: Средняя оценка студента и сдал ли он сессию

Петров               3.833333  true 
Петровский           3.833333  true 
Иванов               3.833333  false
Ивановский           4.000000  false
Запорожцев           4.000000  true 
Сидоров              4.333333  true 
Сидоркин             3.666667  true 
Биткоинов            3.500000  false
Эфиркина             3.833333  false
Сиплюсплюсов         4.166667  true 
Программиро          4.500000  true 
Джаво                3.500000  false
Клавиатурникова      4.166667  true 
Мышин                4.000000  true 
Фулл                 4.000000  true 
Безумников           4.000000  true 
Шарпин               3.666667  true 
Круглосчиталкин      4.000000  true 
Решетников           3.666667  false
Эксель               4.500000  true 
Текстописов          3.500000  false
Текстописова         3.666667  true 
Густобуквенникова    3.500000  false
Криптовалютников     4.166667  true 
Блокчейнис           4.500000  true 
Азурин               4.166667  true 
Вебсервисов          3.666667  false
Круглотличников      3.500000  true 



        Task 3.2: Список двоечников по предметам

Логическое программирование         |  Иванов; Решетников;
Психология                          |  Ивановский; Эфиркина;
Математический анализ               |  Биткоинов; Вебсервисов;
Функциональное программирование     |  Джаво;
Информатика                         |  Текстописов; Густобуквенникова;
Английский язык                     |  Густобуквенникова;



        Task 3.3: Студенты с максимальной суммарной оценкой по группам

101: Запорожцев
102: Блокчейнис
103: Эксель
104: Программиро
```

## Выводы

Выполняя данную лабораторную работу, я продолжила знакомство с концепцией функционального программирования и, в частности, со списками в F#. Я обновила свои знания о рекурсии (обычной и хвостовой) и научилась использовать встроенные функции списков, как map, filter, groupBy и другие, что значительно упростило решение задач. В результате выполнения лабораторной работы я получила практические навыки работы со списками в F#, что является важным шагом в освоении функционального программирования на платформе .NET. Кроме того, я убедилась, что средствами функционального программирования можно эффективно работать с базами данных.

Для изучения встроенных функций F# пользовалась сайтами-справочниками:

https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html (списки)

https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html (последовательности)
